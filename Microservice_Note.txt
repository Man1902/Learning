- Monolitihc Architecture is like a big container wherein all the software components of an application are assembled together and tightly packaged.  
- Monolitihc Architecture Cons / Problems  : 
 * Large and complex application : modularity breaks down.Difficult to understand and implement the new changes. Qality of code decline over time.
 * Slow development : As application grow in size,it is difficult to understand and modify. Makes developer less productive.
 * Block continuous deployment : In order to update one component, need to redploy whole application.
 * Unscalable (as some compoments are CPU insentive and some are Memory insentive).Each components can not be scale individually.
 * Unreliable (as all component are tighly coupled).If one service fails, It will lead down fall of the entire application.
 * Inflexible (Difficult to adopt new framewrok/language)
- Microservices is an architectural style that structures an application as a collection of small autonomous services, modelled around a business domain.
- In Microservices Architecture,each service is self-contained and implements a single business capability.
- Advantages of Microservices Architecture :
 * Independent Development (Easy to build and Maintain)
 * Independent Deployment (Continuous Delievery)
 * Fault Isolation
 * Mixed technology stack
 * Granular scaling (single service can be easily scale up without having to scale the entire application)
- Features of Microservices Architecture : 
  1) Small Focused (Componentization)
  2) Loosely coupled (Decoupling) 
  3) Langauage Neutral 
  4) Bounded context  (single business capability)
  5) Autonomy (less dependent on cross team solution)
  6) Continous Delievery
  7) Decentralized Governance
  8) Agility 
  9) Products not projects
- Best practices to design microservices : 
 * Seprate data store for each microservices
 * Seprate build for each microservices
 * Deploy in container
 * Treat servers a stateless
- Challangges with Microservices : 
 * Configuration management
 * Debugging 
 * Consistency
 * Automating the components
 * Dynamic Scale Up and Scale Down
 * Fault Tolerance
 
				SOA																Microservices
* Follows “share-as-much-as-possible” architecture approach		* Follows “share-as-little-as-possible” architecture approach
* Importance is on business functionality reuse					* Importance is on the concept of “bounded context”
* They have common governance and standards						* They focus on people collaboration and freedom of other options
* Uses Enterprise Service bus (ESB) for communication			* Simple messaging system
* They support multiple message protocols						* They use lightweight protocols such as HTTP/REST etc.
* Multi-threaded with more overheads to handle I/O				* Single-threaded usually with the use of Event Loop features for non-locking I/O handling
* Maximizes application service reusability						* Focuses on decoupling
* Traditional Relational Databases are more often used			* Modern Relational Databases are more often used
* A systematic change requires modifying the monolith			* A systematic change is to create a new service
* DevOps / Continuous Delivery is becoming popular, but not  	* Strong focus on DevOps / Continuous Delivery
  yet mainstream
* Uses Middleware for communication (Messaging Middleware)		* Uses API layer for communication (e.g REST)
- Cohesion refers to the degree to which the elements inside a module belong together.Good design has high cohrsion and low coupling.

- Patterns for distributed transactions within a microservices architecture : 
1) 2pc (two-phase commit) : 
- It has two phases: A prepare phase and a commit phase.
- In the prepare phase, all microservices will be asked to prepare for some data change that could be done atomically. Once all microservices are prepared, the 
  commit phase will ask all the microservices to make the actual changes.
- Normally, there needs to be a global coordinator to maintain the lifecycle of the transaction, and the coordinator will need to call the microservices in the 
  prepare and commit phases.
- Advantage : very strong consistency protocol. allows read-write isolation
- Disadvantage : It is synchronous (blocking).
2) Saga pattern : 
- It is asynchronous and reactive.In this pattern, the distributed transaction is fulfilled by asynchronous local transactions on all related microservices. The
  microservices communicate with each other through an event bus.
- Whenever first Microservice receives a request to update/create a data, It first starts a local transaction to update/create data and then emits an Created 
  event.The second Microservice listens for this event and updates its data once the event is received.If updation is successfully,Updated event will then be 
  emitted, which in this example means the end of the transaction.
- If any microservice fails to complete its local transaction, the other microservices will run compensation transactions to rollback the changes. 
- Advantages : support for long-lived transactions.
- Disadvantages  : difficult to debug when many microservices are involved.Event messages could become difficult to maintain if the system gets complex.
  It does not have read isolation.
- To address the complexity issue of the Saga pattern, it is quite normal to add a process manager as an orchestrator. The process manager is responsible for 
  listening to events and triggering endpoints.
---------------------------------
- Design pattern used in Microservice Architecture (e.g Service Discovery and Registry)
- Distributed transactions management in microservices(Patterns for distributed transactions within a microservices architecture)
- Fault toerance
- Security across distributed services
- Configuration Server
----------------------------